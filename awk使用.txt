awk里的注释是从#开始到该行结束
反斜杠,转义序列允许非打印字符的表示
"A\tZ"包含是,字符A,制表符(tab),以及字符Z,而"\001"与"\x01"则每个只是包含了ctrl-A字符

正则表达式常量可以用引号或斜杠加以定界
如果需要在正则表达式里使用反斜杠时,则它也应该被保护,但引号形式则需要额外层级的保护:"\\\\Tex"与/\\Tex/都匹配包含\Tex的字符串的则正表达式

awk并没有提供字符串转数字的函数.
awk的做法很简单:只需要加个零到字符串里,如:s="123"接着是n=0+s,便将数字123赋值给n

通过这样把字符串转换为数字:"+123ABC"转换为123,而"ABC","ABC123"与" " 将会转换成0,就可以强制非数值字符串转换成数字

尽管记录通常是被换行符所分隔的数行文本,但awk允许更具通用性地通过记录分隔字符内建变量

RS
在传统的与POSIX的awk里,RS必须是单一字面,字符,例如换行符号(默认值),或是空字符串,后者会被特殊处理:记录是由一个或多个空行所分隔的段落,且位于文件起始或结尾处的空行会被忽略,字段则再由换行字符,或FS里所设置的任何字符加以分隔

字段彼此是被匹配字段分隔字符正则表达式(可在变量FS里取得)的当前字符串值分隔.


FS的默认值为单一空格(space),它接受特殊的解释方式:一个或多个空白字符(空格,与制表符)以及行的开头与结尾的空白都将被忽略

当使用单一空格分隔字段时,只要设置FS="[ ]"以正好匹配一个空格即可,在这样的设置下,前置有结尾的空格不会被忽略.

FS只有它在超过一个字符时,才会被视为正则表达式,FS=".",指的是以.作为字段分隔字符,而不是正则表达式所指的任何单一字符


模式是由字符串与/或数值表达式构建而成
下面的例子是选定模式时,常用的几种形式:
NF==0                           选定空记录
NF>3                            选定拥有3个字段以上的记录
NF<5                            选定第1到第4条记录
(FNR==3) && (FILENAME ~/[.][ch]$/)          于c来源文件中选定记录3
$1 ~ /jones/                选定字段1里有"jones"的记录,$1 !~ /jones/,表示字段1里不包含"jones"
/[Xx][Mm][Ll]/              选定含有"XML"的记录,并忽略大小写差异
$0 ~ /[Xx][Mm][Ll]/     同上


awk在匹配上,还可以使用范围表达式,这里有几个例子:
(FNR==3),(FNR==10)      选定每个输入文件里记录3到10
/[aeoiouy][aeiouy]/,/[^aeiouy][^aeiouy]/   #这里指非元音 选定起始于两个元音,结尾为两个福音的记录.

在BEGIN操作里,FILENAME,FNR,NR与NF初始都未定义;引用它们时,会返回Null字符串或零


以最简单的形式来说,纯print意指在标准输出上,打印当前的输入记录($0),接着是输出记录分隔符ORS的值,默认为单一换行字符

更常见的用法是:一个print语句里包含以逗点隔开的零或多个表达式
例如:
$echo 'one two three four' |awk '{print $1,$2,$3}'
one two thress

$echo 'one two three four' |awk '{OFS="..."; print $1,$2,$3}'
one...two...three...four

$echo 'one two three four' |awk '{OFS="\n";print $1,$2,$3}'
one
two
three

改变输出字段分隔符而没有指定任何字段,不会改变$0
$echo 'one two three four' |awk '{OFS="\n";print $0}'
one two three four

如果要用上边的方式(使用$0),更改输出字段分隔符,并指定至少一个字段(即使没有改变其值),强制以新的字段分隔符重新组合记录
$echo 'one two three four' |awk '{OFS="\n";$1=$1;print $0}'
one
two
three
four


数组成员测试
成员测试key in array是一个表达式:
如果key为array的一个索引元素,则计算为1(真),此外,也可通过否定运算符反转测试:如果key不是array的一个索引元素,则!(key in array)为1,对于具有多下标的数组,在测试时使用圆括号,并用逗点分隔下标列表:
(i,j,...,n) in array

成员测试不可能建立数组元素,然而引用元素时,如果元素不存在,则会建立他:
因此应该这么写:
if("sallay" in telepone)
    print "Sally is the directory"

而

if("telephone["sally"] != " ")
    print "salary is in the directory"

会在(salary)不存在时,将其加入到目录里,并拥有一个空电话号码


通过getline语句可以处理从文件中或命令行上的内容或文件
getline的各种语法

getline                        从当前输入文件中,读取一条记录,存入$0,并更新NF,NR与NFR
getline var                 从当前输入文件中,读取下一条记录,存入var,并更新NR和FNR
getline < file             从file中读取下一条记录,存入$0,并更新NF
getline var < file      从file中读取下一条记录,存入var,存入var

例子:
print "what is the square root of 625?"
getline answer
print "Your reply: ",answer ", is", (answer == 25)? "night." : "wrong."

如果我们想要确保输入来自控制终端,而非标准输入,则改用:
getline answer < "/dev/tty"


从字典中载入单词列表:
nwords = 1
while((getline words[nwords] < "/usr/dict/words") > 0)
     nwords++

命令管道在awk里可以发挥强大的功能
"date" | getline now
close("date")
print The current time is", now.

大部分系统都会限制打开文件的个数,所以当使用管道通过时,通过close()函数关闭管道文件.


如何在循环里使用命令管道
command = "head -n 15 /etc/hosts"
while((command | getline s) > 0)
    print s
close(command)


getline语句可以与外部程序通信
system(command)函数提供一种方式,其返回值是命令的退出状体码
首先,它会先清除所有缓存区输出,然后开始一个/bin/sh实例并将命令送给它

system()函数提供了简单删除临时文件的方式:
system("rm -f" tmpfile)

传递给system()的命令可包含数行:
system("cat <<EOFILE\nuno\ndos\ntres\nEOFILE")
会产生如下的输出:
uno
dos
tres

由于每次调用system()都会起始一个全新的shell,因此没有简单方式可以在分开的system()调用内的命令之间传递数据,除非通过中间文件.
下面有个简单解决方案,将输出管道送到shell,以送出多个命令
Shell="/usr/local/bin/ksh"
print "export INPUTFILE=/var/tmp/myfile.in" |Shell
print "export OUTPUTFILE=/var/tmp/myfile.out" |Shell
print "evn|grep PUTFILE"|Shell
close(Shell)

这中方法还提供一个功能:你可以选择Shell


函数定义如下:
function name(arg1, arg2, arg3, ... argn) {
    statement(s)
}

指定的参数在函数体中用来当作局部变量,调用形式为:
name(expr1,expr2 ... exprn)     忽略任何的返回值
result=name(expr1,expr2 ... exprn)      返回值存储到result中


awk针对当前输入记录$0自动提供了方便的分割$1,$2,$3,$4 ..... $NF,也可以用函数来做:
split(string,array,regexp)将string切割为片段.并存储到array里的连续元素,函数会返回array里元素数量.

split(string,chars," "),将string分割为单字符元素放置到chars[1],chars[2],...,chars[length(string)]中,调用split(" ",array)可删除array里所有元素,这个方法比使用循环进行数组元素删除还快


BEGIN模式用于指定在第一个输入行读入之前要执行的动动作

$awk 'BEGIN {print "hello, world"}'

如果一个程序只有一个BEGIN模式,并且没有其他语句,awk将不处理任何输入文件

在END模式中放置print语句,当读完最后一个空行后打印x的值

$ awk '/^S/ {print  ++x} END {print x}'



* 模式匹配

$echo 4T |awk '/[0-9 ]+/ {print "Integer"} /[A-Za-z ]+/ {print "string"}'
Integer
string

一行可以匹配一条或多条规则,如上,4T及匹配数字,同时也匹配字符,包含一个或者多个数字序列的行也被看作一个整数


$ awk -F"\t" '{print $2}' names

"\t"是表示一个实际的制表符转义序列,应由但引号或双引号包围


$ echo a,b,978,c,e,696--0987 |awk 'BEGIN {FS=","} {print $1","$6}'      #用逗号作为分隔字段
a,696--0987


$6 ~ /1?(-| )?\(?[0-9]+\)?( |-)?[0-9}+-[0-9]+/

这里的正则表达式分段解释
"1?"           表示出现0个或者1个1
"(-| )?"        表示在随后的位置查找一个"-"或者一个空格,或者什么都没有;
"\(?"           表示查找0个或者1个"(",反斜杠能防止将"("解释为用于分组的元字符
"[0-9]+"    表示查找1个或者多个数字,这里采用了简便的方式,仅指定一到多位数字,而不是精确的指定3位数字
随后,查找一个可选的")",接着查找一个空格或者"-",或者什么都没有
然后"[0-9]+",查找一到多位数字,随后跟一个"-",最后跟一到多位数字


FS="\t"       #表示将每个制表符作为一个字段分隔符
FS="\t+"    #表示用一个或者多个制表符来分隔字段
FS="[,:\t]"   #在括号中的任何3个字符之一都可以解释为字段分隔符


和FS等效的输出是OFS,它的默认值是一个空格,表示的输出的内容分隔符


$ cat /etc/passwd |awk '{print NR "." $0}'
1.root:x:0:0:root:/root:/bin/bash
2.daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
3.bin:x:2:2:bin:/bin:/usr/sbin/nologin

NR表示记录编号

$ cat /etc/passwd |awk 'BEGIN {FS=":"} {print $1} END {print " "; print NR, "records"}'
root
daemon
bin
.....

46 records


# 文件内容
John Robinson
Koren Inc.
978 Commonwealth Ave.
Boston
MA 01760
969-0987

a
b
c
d

$ cat a.txt |awk 'BEGIN {FS="\n";RS=""} {print $1, $NF}'
John Robinson 969-0987
a d

FS用的"\n"表示换行符被认为是字段之间的分隔符,也就是列的分隔符
RS是用于匹配多行的,行与行之间的分隔符,比如上述RS的设定,表示空行被认为是2行的分隔符
$NF则是当前的匹配的字段号,和$1,$2,..对应,NF则是表示字段总数,比如:

root:x:0:0:root:/root:/bin/bash

使用":"作为分隔符,$NF为最后一个字段的值,NF则是字段总数

$ cat /etc/passwd |awk 'BEGIN {FS=":"} {printf NF; printf " " $1 " "; print $NF}'
7 root /bin/bash
.......

这是结果,NF是一行的字段总数7,$NF则是最后一个字段的内容


$ cat a.txt |awk 'BEGIN {FS="\n";RS="";OFS="||";ORS="\n-----\n"} {print $1,$NF}'
John Robinson||969-0987
-----
a||d
-----

OFS表示输出时候的记录之间的分隔符
ORS表示行之间的分隔符,默认是换行符


使用条件判断的时候的格式
$ cat /etc/passwd |awk -F":" '$7 ~ /\/bin\/bash/ { print $0}'
$ cat /etc/passwd |awk 'BEGIN { FS=":" } $7 ~ /\/bin\/bash/ { print $0}'

root:x:0:0:root:/root:/bin/bash
jack:x:1000:1000:jack,,,:/home/jack:/bin/bash

上2句等价,条件判断语句写在{}外部,还有正规的写法:

$ cat /etc/passwd |awk 'BEGIN { FS=":" }{ if($7 ~ /\/bin\/bash/) { print $0}}'


$ cat /etc/passwd |awk 'BEGIN {FS=":"} $1 == var {print $0}' var=root
root:x:0:0:root:/root:/bin/bash

传递外部参数,var作为参数传递到awk中,可以在任何地方使用,但是如果是在正则表达式中,不能用上述方式,要使用

$ cat /etc/passwd |awk 'BEGIN {FS=":"} $1 ~ /'"$var"'/ {print $0}' var=root
root:x:0:0:root:/root:/bin/bash

注意是变量必须加"$"符号,而且,必须是内层用双引号,外层用单引号

这里比较有趣的现象是当使用正则表达式的时候,需要使用'"$var"'的方式来使用变量,但是不使用正则表达式的时候,则只能用var来使用变量


*** 应用
* 从文本格式的表格中抽取数据
--------------------------------------------------------------------------------------
假设有一个文本文件名为DPL,其中存放着所有前Debian项目领导人的名字和他们的上台日期,表格格式是以空格做为分隔的.

Ian     Murdock   August  1993
Bruce   Perens    April   1996
Ian     Jackson   January 1998
Wichert Akkerman  January 1999
Ben     Collins   April   2001
Bdale   Garbee    April   2002
Martin  Michlmayr March   2003

Awk经常用于从这类文件中提取数据.
--------------------------------------------------------------------------------------
$ awk '{ print $3 }' <DPL                   # month started
August
April
January
January
April
April
March
$ awk '($1=="Ian") { print }' <DPL          # DPL called Ian
Ian     Murdock   August  1993
Ian     Jackson   January 1998
$ awk '($2=="Perens") { print $3,$4 }' <DPL # When Perens started
April 1996

* 计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）：
awk '{ x += $3 } END { print x }' myfile

* 如何在 awk 中使用'()'作为分隔符
比如现在有这样一个文件 some.log 文件内容如下

Grape(100g)1980
raisins(500g)1990
plum(240g)1997
apricot(180g)2005
nectarine(200g)2008

现在我们想将上面的 some.log 文件中按照 "水果名称(重量)年份" 来进行分割

$ awk -F '[()]' '{print $1, $2, $3}' some.log
Grape 100g 1980
raisins 500g 1990
plum 240g 1997
apricot 180g 2005
nectarine 200g 2008

在 -F 参数中使用一对方括号来指定多个分隔符，awk 处理 some.log 文件时就会使用 "(" 和 ")" 来对文件的每一行进行分割。

* 如何在 awk 中使用'[]'作为分隔符

假如有如下文件 test.txt:

a[123]c
b[dgfds]edfs
c[7394]@42

$ awk -F'[][]' '{print $2}' test.txt
123
dgfds
7394

* 使用'做分配符,或者使用 \047 代替
例如有如下文件 a.txt:
 
'(abc)' '(def)' 
'(123343)' '(#@$@#)'

$ awk -F'\047' '{print $2}' a.txt
(abc)
(123343)

$ awk -F''\''' '{print $4}' a.txt
(def)
(#@$@#)











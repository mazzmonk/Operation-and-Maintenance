 
Perl 程序中,正则表达式有三种存在形式

分别是

(1 模式匹配：m/<regexp>/     #平时我们简写 /<regexp>/ ,略去m,

三个参数

/i不区分大小写   /s匹配任何字符    /x添加空格  /o 不重复编译正则表达示

(2 模式替换：s/<pattern>/<replacement>/

 /g    进行全局替换           
 \U     大小写转换,例如s/(fred|barney)/\U$1/gi;
\L    转换小写                   \E    影响到剩余的(替换的)字符串
\l 和\u    写形式时(\l 和\u),只作用于下一个字符

(3 模式转化：tr/<pattern>/<replacemnt>/

这三种形式一般都和 =~ 或 !~ 搭配使用,"=~" 表示相匹配(does),"!~" 表示不匹配(doesn’t）,并在左侧有待处理的标量变量.如果没有该要处理的变量,则默认为处理 $_ 变量中的内容.

 

表达式中的一些常用模式.

/表达式/	结果
.	匹配除换行符以外的所有字符
x?	匹配 0 次或一次 x 字符串
x*	匹配 0 次或多次 x 字符串,但匹配可能的最少次数
x+	匹配 1 次或多次 x 字符串,但匹配可能的最少次数
.*	匹配 0 次或多次的任何字符
.+	匹配 1 次或多次的任何字符
{m}	匹配刚好是 m 个 的指定字符串
{m,n}	匹配在 m个 以上 n个 以下 的指定字符串
{m,}	匹配 m个 以上 的指定字符串
[]	匹配符合 [] 内的字符
[^]	匹配不符合 [] 内的字符
[0-9]	匹配所有数字字符
[a-z]	匹配所有小写字母字符
[^0-9]	匹配所有非数字字符
[^a-z]	匹配所有非小写字母字符
^	匹配字符开头的字符
$	匹配字符结尾的字符
\d	匹配一个数字的字符,和 [0-9] 语法一样
\d+	匹配多个数字字符串,和 [0-9]+ 语法一样
\D	非数字,其他同 \d
\D+	非数字,其他同 \d+
\w	英文字母或数字的字符串,和 [a-zA-Z0-9] 语法一样
\w+	和 [a-zA-Z0-9]+ 语法一样
\W	非英文字母或数字的字符串,和 [^a-zA-Z0-9] 语法一样
\W+	和 [^a-zA-Z0-9]+ 语法一样
\s	空格,和 [\n\t\r\f] 语法一样
\s+	和 [\n\t\r\f]+ 一样
\S	非空格,和 [^\n\t\r\f] 语法一样
\S+	和 [^\n\t\r\f]+ 语法一样
\b	匹配以英文字母,数字为边界的字符串
\B	匹配不以英文字母,数值为边界的字符串
a|b|c	匹配符合a字符 或是b字符 或是c字符 的字符串
abc	匹配含有 abc 的字符串
(pattern)	() 这个符号会记住所找寻到的字符串,是一个很实用的语法.第一个 () 内所找到的字符串变成 $1 这个变量或是 \1 变量,第二个 () 内所找到的字符串变成 $2 这个变量或是 \2 变量,以此类推下去.
/pattern/i	i 这个参数表示忽略英文大小写,也就是在匹配字符串的时候,不考虑英文的大小写问题.
\	如果要在 pattern 模式中找寻一个特殊字符,如 "*",则要在这个字符前加上 \ 符号,这样才会让特殊字符失效
*?  +?   ??  为这三个数量词的非贪婪的类型

 perl中的扩展模式匹配

/pattern(?=string)/ 肯定和否定的见匹配?=和?-,这个在(?=)中的内容不会存到$&中

perl处理完后会给匹配到的值存在三个特殊变量名

$&, $`, $’.匹配上的那部分字符串将自动存储在$&之中.变量$1 中的值为 there,而$&为整个被匹配的部分,匹配部分的前一部分存放在$`之中,后一部分被存到$’.另一种说法是,$`中含有正则表达式引擎在匹配 成功前所找到的变量,而$’为此模式还没有匹配的剩余部分.如果将这三个变量放在一起,你将得到原始字符串

括号的特殊用法

(?#text) 忽略括号内的注释文本；
(?:pattern) 与组一致,但匹配时不生成$1,$2,也就是不捕获；
(?imsx:pattern) 与组一致,但匹配时不生成$1,$2,在特定的风格有效期间,内嵌风格匹配修饰符；
(?=pattern) 前看声明,如果正则表达式在下一次匹配 pattern 风格,就开始匹配,而且不影响匹配效果.如/\w+(?=\t)/将匹配制表符是否恰好在一个字\w+后面出现,并且制表符不添加到$&的值中；
(?!pattern) 如果正则表达式在后面不匹配 pattern ,才会开始匹配.如/foo(?!bar)/,只有当出现 foo,并且后面不出现 bar 时才开始匹配；
(?<=pattern) 后看声明,只有在pattern已经匹配下面的表达式,并且不将 pattern 的结果放入$&变量中,才匹配下面的语句.如/(?<=\t)\W+/匹配制表符是否恰好在\W+前出现,但又不将制表符送到$& 中；
(? (?{code}) 表示对 code 的使用是试验性的.如果返回真,就认为是与(?:pattern)断言同一行里的匹配.code 不插入变量.这个断言仅仅在 use re ‘eval’ 编译指示符时才有效；
(?>pattern) 如果类型锁定在当前位置,就使用单独的 pattern 匹配子字符串.如正则表达式/^(?>a*)ab/永远不会匹配,因为语句(?>a*)将匹配字符串开头所有的 a 字符,并删除与 ab 匹配的字符 a；
(!<=pattern) 非后看声明,与后看声明意思相反；
(!=pattern) 非前看声明,与前看声明意思相反；
(?(condition)yes-pattern|no-pattern) 条件表达式——条件语句或者是一个圆括号中的整数,或者是一个断言；
(?(condition)yes-pattern)
(?imsx) 嵌入风格匹配修饰符.当要把表达式修改符嵌入在变量中,然后把变量用在不指定自己的修饰符的一般规则表达式中；
(?-imsx) 这个断言很有用——后面带任何内容都会关闭修饰符,直到出现另一个嵌入的修饰符.

 
Perl 中特殊正则元字符使用和环顾断言:
1. *? 和 +? 和 {n,}?  懒惰匹配

非懒惰 　　　　　　　　　　　　　　　
echo "ab2c121a" |perl -ne 'print $1 if /(.*)"d/;'   #print ab2c12

懒惰
echo "ab2c121a" |perl -ne 'print $1 if /(.*?)"d/;'   #print ab

2.回溯引用和前后查找:
向前查找(?=..)  找字符串前面的内容,找到算成立 　　　　　　　　　　　　

echo "ab2c121a" |perl -ne 'print $1 if /(.*?)(?=2)/;'  #print ab
向后查找(?<=..)  找字符串后面的内容,找到算成立    　　　　　　

echo "ab2c121a" |perl -ne 'print $1 if /(?<=2)(.*)(?=2)/;' #print c1
负向-前/后 查找 (?!…)(?<!..)   找字符串前后的内容,如果不存在为真

echo "ab2c121a" |perl -ne 'print $1 if /(?<!--2)(c.*)/;'  #print 无
echo "ab2c121a" |perl -ne 'print $1 if /(?<!3)(c.*)/;'  #print c121a
</pre-->

向前和向后的分别在于,是找当前字符的前面还是后面的部分.如上ab2c121a ,比如在2c的前面是ab后面是121a.
负向的前后查找主要在于,条件不一样,上面是找到为真,但负向是没有找到为真.

条件?() = if ?()| = if else
?()例如<p></p>必须同时出现

echo "<p>xx</p>"|perl -ne 'print $2  if /(<p>)?("w*)(?(1)<"/p>)/'   #print  xx echo "</p><p>xx"|perl -ne 'print $2,""n" if /(</p><p>)?("w*)(?(1)<"/p>)/'    #print 空 echo "xx"|perl -ne 'print $2 if /(</p><p>)?("w*)(?(1)<"/p>)/'    #print xx</p>

?()|例如还是上面的, 当有<p>可以接</p>也可以接数字结尾
echo "<p>xx1</p>"|perl -ne 'print $2  if /(<p>)?("w*)(?(1)<"/p>|"d)/'  #print xx1  echo "</p><p>xx1"|perl -ne 'print $2  if /(</p><p>)?("w*)(?(1)<"/p>|"d)/'    # print xx</p>
 

可选的修饰符

    有几个修饰符,通常叫做标记,可以后缀在正则表达式后面来改变其默认的行为.
    /i :不区分大小写
    /s :匹配任何字符. 例如: 点(.)不匹配换行符,如果加上/s这个修饰符,它将点(.)的行为变成同字符类[\d\D]的行为类似,可以匹配任何字符,包括换行符.
    /x :添加空格. /x修饰符允许你在模式中加入任何数量的空白,以方便阅读.      
        例如: (/-? \d+ \.? \d* /x) 等同于 (/-?\d+\.?\d*/)
 
    将可选修饰符结合起来,其顺序是不重要的. 例如 (/barney.*fred/is)
 
Perl 正则的优化
 
（1  使用 /o 来优化要多次运行但不修改的表达示
（2  使用 qr 在运行前编译要多次运行的正则表达示
（3  短字符用 /aaa/ || /bbb/ || /ccc/分割比 /aaa|bbb|ccc/ 速度快
 ( 4  试着用 study  模式来学习正则
 
判断当前位置的前后字符,是否符合指定的条件,但不匹配前后的字符.

说明
预搜索有向前和向后两种：

表达式
方向
说明
(?=xxx)
正向预搜索（向右）
正向预搜索,判断当前位置右侧是否能匹配指定表达式
(?!xxx)
正向预搜索否定,判断当前位置右侧是否不能够匹配指定表达式
(?<=xxx)
反向预搜索（向左）
反向预搜索,判断当前位置左侧是否能够匹配指定表达式
(?<!xxx)
反向预搜索否定,判断当前位置左侧是否不能够匹配指定表达式
正向预搜索内部的表达式,始终采用“普通模式（从左向右）”模式,反向预搜索内部的表达式,始终采用 “从右向左”模式.
例如：想要匹配字符a但不匹配abc,可以为/a(?!bc)/
再如：想要所有以.pl结尾但不是a.pl的文件名,可以/.*(?<!a)\.pl/; 注意要从右向左,
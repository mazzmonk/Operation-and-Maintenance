linux中，nm用来列出目标文件的符号清单。
下面是nm命令的格式：　nm [-a|--debug-syms] [-g|--extern-only] [-B][-C|--demangle] [-D|--dynamic] [-s|--print-armap][-o|--print-file-name] [-n|--numeric-sort][-p|--no-sort] [-r|--reverse-sort] [--size-sort][-u|--undefined-only] [-l|--line-numbers] [--help][--version] [-t radix|--radix=radix][-P|--portability] [-f format|--format=format][--target=bfdname] [objfile...]
如果没有为nm命令指出目标文件，则nm假定目标文件是a.out。下面列出该命令的任选项，大部分支持“-”开头的短格式和“—“开头的长格式。
-A、-o或--print-file-name：在找到的各个符号的名字前加上文件名，而不是在此文件的所有符号前只出现文件名一次。
例如nm libtest.a的输出如下：
CPThread.o:
00000068 T Main__8CPThreadPv
00000038 T Start__8CPThread
00000014 T _._8CPThread
00000000 T __8CPThread
00000000 ? __FRAME_BEGIN__
…………………………………
则nm –A 的输出如下：
libtest.a:CPThread.o:00000068 T Main__8CPThreadPv
libtest.a:CPThread.o:00000038 T Start__8CPThread
libtest.a:CPThread.o:00000014 T _._8CPThread
libtest.a:CPThread.o:00000000 T __8CPThread
libtest.a:CPThread.o:00000000 ? __FRAME_BEGIN__
…………………………………………………………
-a或--debug-syms：显示调试符号。
-B：等同于--format=bsd，用来兼容MIPS的nm。
-C或--demangle：将低级符号名解码(demangle)成用户级名字。这样可以使得C++函数名具有可读性。
-D或--dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。
-f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。
-g或--extern-only：仅显示外部符号。
-n、-v或--numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。
-p或--no-sort：按目标文件中遇到的符号顺序显示，不排序。
-P或--portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。
-s或--print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。
-r或--reverse-sort：反转排序的顺序(例如，升序变为降序)。
--size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。
-t radix或--radix=radix：使用radix进制显示符号值。radix只能为“d”表示十进制、“o”表示八进制或“x”表示十六进制。
--target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。
-u或--undefined-only：仅显示没有定义的符号(那些外部符号)。
-l或--line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。对于已定义的符号，查找符号地址的行号。对于未定义符号，查找指向符号重定位入口的行号。如果可以找到行号信息，显示在符号信息之后。
-V或--version：显示nm的版本号。
--help：显示nm的任选项。
…………………………………………
输出符号类型说明（大写表示全局，小写表示局部）
A
该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。
B
该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为B，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中
C
该符号为common。common symbol是未初始化数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。
补充：该符号所占的空间并不存在于执行文件中，而在初始化执行环境时分配此空间，但不会清零，可读写。
D
该符号位于初始话数据段中。一般来说，分配到data section中。例如定义全局int baud_table[5] = {9600, 19200, 38400, 57600, 115200}，则会分配于初始化数据段中。
补充：该符号所占用的空间存在于执行文件中，在初始化执行环境时分配，并复制数据到此空间，可读写。
G
该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。
I
该符号是对另一个符号的间接引用。
N
该符号是一个debugging符号。
R
该符号位于只读数据区。例如定义全局const int test[] = {123, 123};则test就是一个只读数据区的符号。注意在cygwin下如果使用gcc直接编译成MZ格式时，源文件中的test对应_test，并且其符号类型为D，即初始化数据段中。但是如果使用m6812-elf-gcc这样的交叉编译工具，源文件中的test对应目标文件的test,即没有添加下划线，并且其符号类型为R。一般而言，位于rodata section。值得注意的是，如果在一个函数中定义const char *test = “abc”, const char test_int = 3。使用nm都不会得到符号信息，但是字符串“abc”分配于只读存储器中，test在rodata section中，大小为4。
补充：此符号所占用的空间存在于执行文件中，是否使用副本空间并不确定。只读。
S
符号位于非初始化数据区，用于small object。
T
该符号位于代码区text section。
U
该符号在当前文件中是未定义的，即该符号的定义在别的文件中。例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。
V
该符号是一个weak object。
W
The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.
-
该符号是a.out格式文件中的stabs symbol。
?
该符号类型没有定义


ar基本用法
　　ar命令可以用来创建、修改库，也可以从库中提出单个模块。库是一单独的文件，里面包含了按照特定的结构组织起来的其它的一些文件（称做此库文件的member）。原始文件的内容、模式、时间戳、属主、组等属性都保留在库文件中。

　　下面是ar命令的格式：

　　ar [-]{dmpqrtx}[abcfilNoPsSuvV] [membername] [count] archive files...

　　例如我们可以用ar rv libtest.a hello.o hello1.o来生成一个库，库名字是test，链接时可以用-ltest链接。该库中存放了两个模块hello.o和hello1.o。选项前可以有‘-'字符，也可以没有。下面我们来看看命令的操作选项和任选项。现在我们把{dmpqrtx}部分称为操作选项，而[abcfilNoPsSuvV]部分称为任选项。

　　{dmpqrtx}中的操作选项在命令中只能并且必须使用其中一个，它们的含义如下：

d：从库中删除模块。按模块原来的文件名指定要删除的模块。如果使用了任选项v则列出被删除的每个模块。
m：该操作是在一个库中移动成员。当库中如果有若干模块有相同的符号定义(如函数定义)，则成员的位置顺序很重要。如果没有指定任选项，任何指定的成员将移到库的最后。也可以使用'a'，'b'，或'I'任选项移动到指定的位置。
p：显示库中指定的成员到标准输出。如果指定任选项v，则在输出成员的内容前，将显示成员的名字。如果没有指定成员的名字，所有库中的文件将显示出来。
q：快速追加。增加新模块到库的结尾处。并不检查是否需要替换。'a'，'b'，或'I'任选项对此操作没有影响，模块总是追加的库的结尾处。如果使用了任选项v则列出每个模块。 这时，库的符号表没有更新，可以用'ar s'或ranlib来更新库的符号表索引。
r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。
t：显示库的模块表清单。一般只显示模块名。
x：从库中提取一个成员。如果不指定要提取的模块，则提取库中所有的模块。
　　下面在看看可与操作选项结合使用的任选项：

a：在库的一个已经存在的成员后面增加一个新的文件。如果使用任选项a，则应该为命令行中membername参数指定一个已经存在的成员名。
b：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项b，则应该为命令行中membername参数指定一个已经存在的成员名。
c：创建一个库。不管库是否存在，都将创建。
f：在库中截短指定的名字。缺省情况下，文件名的长度是不受限制的，可以使用此参数将文件名截短，以保证与其它系统的兼容。
i：在库的一个已经存在的成员前面增加一个新的文件。如果使用任选项i，则应该为命令行中membername参数指定一个已经存在的成员名(类似任选项b)。
l：暂未使用
N：与count参数一起使用，在库中有多个相同的文件名时指定提取或输出的个数。
o：当提取成员时，保留成员的原始数据。如果不指定该任选项，则提取出的模块的时间将标为提取出的时间。
P：进行文件名匹配时使用全路径名。ar在创建库时不能使用全路径名（这样的库文件不符合POSIX标准），但是有些工具可以。
s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。甚至对于没有任何变化的库也作该动作。对一个库做ar s等同于对该库做ranlib。
S：不创建目标文件索引，这在创建较大的库时能加快时间。
u：一般说来，命令ar r...插入所有列出的文件到库中，如果你只想插入列出文件中那些比库中同名文件新的文件，就可以使用该任选项。该任选项只用于r操作选项。
v：该选项用来显示执行操作选项的附加信息。
V：显示ar的版本

GNU工具中ar是用来制作库文件.a的，但同时还提供了一个ranlib，从手册上看ranlib相当于ar -s，为什么这样呢？

这是由于最早在Unix系统上ar程序是单纯用来打包多个.o到.a（类似于tar做的事情），而不处理.o里的符号表。Linker程序则需 要.a文件提供一个完整的符号表，所以当时就写了单独的ranlib程序用来产生linker所需要的符号信息，也就是说那时，产生一个对linker合 格的的.a文件需要做ar和ranlib两步 。

很快，Unix厂商就发现ranlib做得事情完全可以合并到ar里面去，于是ar程序的升级版本就包括了ranlib的功能，但早期的很多项目的Makefile都已经是按照两步式的方法生成.a，所以为了保证这些早期文件的兼容性，ranlib被保留下来了。

如今，GNU/Linux系统上，ranlib依然存在，当然大部分项目已经不使用它了，因为ar -s就做了ranlib的工作。
历史通常是进步和妥协的混合！



LD_LIBRARY_PATH: 动态库的查找路径
设置：
方法一： export  LD_LIBRARY_PATH=LD_LIBRARY_PATH:/XXX 但是登出后就失效
方法二： 修改~/.bashrc或~/.bash_profile或系统级别的/etc/profile
         1. 在其中添加例如export PATH=/opt/ActiveP/lib:$LD_LIBRARY_PATH
         2. source .bashrc  (Source命令也称为“点命令”，也就是一个点符号（.）。source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录)
方法三：这个没有修改LD_LIBRARY_PATH但是效果是一样的实现动态库的查找， 
         1. /etc/ld.so.conf下面加一行/usr/local/mysql/lib
         2. 保存过后ldconfig一下（ldconfig 命令的用途,主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下,搜索出可共享的动态链接库(格式如前介绍,lib*.so*),进而创建出动态装入程序(ld.so)所需的连接和缓存文件.缓存文件默认为/etc/ld.so.cache,此文件保存已排好序的动态链接库名字列表.）
        方法三设置稍微麻烦，好处是比较不受用户的限制。
例如：
对于用户production的LD_LIBRARY_PATH进行分析如下：
1、production@Africa:~> echo $LD_LIBRARY_PATH
/home/production/cpst/cptools/lib:/home/production/cpst/campost/lib:/home/production/tuxedo/lib:/home/production/tuxedo/jre/lib/amd64/server:/home/production/tuxedo/jre/jre/bin:/usr/lib:/usr/lib64:/lib:/lib64:/usr/local/lib:/usr/local/lib64:/oracle/product/11gR2/db/lib:/oracle/product/11gR2/db/ctx/lib
2、查看.profile：
.profile中有： . ~/cpst/campost/config/setenv，说明用户启动是运行脚本setenv。
3、setenv中有：
export CAMPOST_HOME=$HOME/cpst/campost
export CPTOOLS_ROOT=$HOME/cpst/cptools
export LD_LIBRARY_PATH=$CPTOOLS_ROOT/lib:$CAMPOST_HOME/lib:$LD_LIBRARY_PATH
4、setenv中有$LD_LIBRARY_PATH，进root查看：
（1）Africa:~ # echo $LD_LIBRARY_PATH
/usr/lib:/usr/lib64:/lib:/lib64:/usr/local/lib:/usr/local/lib64:/oracle/product/11gR2/db/lib:/oracle/product/11gR2/db/ctx/lib
（2）etc/profile中有：
export LD_LIBRARY_PATH=/usr/lib:/usr/lib64:/lib:/lib64:/usr/local/lib:/usr/local/lib64:$LD_LIBRARY_PATH
（3）/etc/profile.d/oracle.sh中有:
LD_LIBRARY_PATH=${LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:}$ORACLE_HOME/lib:$ORACLE_HOME/ctx/lib


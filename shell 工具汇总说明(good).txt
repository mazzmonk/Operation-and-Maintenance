. 在 Bash 中, 可以按下 ctrl-w 删除你键入的最后一个单词, ctrl-u 可以删除行内光标所在位置之前的内容, alt-b 和 alt-f 可以以单词为单位移动光标, ctrl-a 可以将光标移至行首, ctrl-e 可以将光标移至行尾, ctrl-k 可以删除光标至行尾的所有内容, ctrl-l 可以清屏.键入 man readline 可以查看 Bash 中的默认快捷键.内容有很多, 例如 alt-. 循环地移向前一个参数, 而 alt-* 可以展开通配符.

. 键入 history 查看命令行历史记录, 再用 !n(n 是命令编号)就可以再次执行.其中有许多缩写, 最有用的大概就是 !$,  它用于指代上次键入的参数, 而 !! 可以指代上次键入的命令了(参考 man 页面中的“HISTORY EXPANSION”).不过这些功能, 你也可以通过快捷键 ctrl-r 和 alt-. 来实现.

. 使用 xargs ( 或 parallel).他们非常给力.注意到你可以控制每行参数个数(-L)和最大并行数(-P).如果你不确定它们是否会按你想的那样工作, 先使用 xargs echo 查看一下.此外, 使用 -I{} 会很方便.例如:

      find . -name '*.py' | xargs grep some_function
      cat hosts | xargs -I{} ssh root@{} hostname

. pstree -p 以一种优雅的方式展示进程树.

. 使用 pgrep 和 pkill 根据名字查找进程或发送信号(-f 参数通常有用).

. 使用 nohup 或 disown 使一个后台进程持续运行.

. 使用 netstat -lntp 或 ss -plat 检查哪些进程在监听端口(默认是检查 TCP 端口; 添加参数 -u 则检查 UDP 端口)或者 lsof -iTCP -sTCP:LISTEN -P -n (这也可以在 OS X 上运行).

. 当变量和文件名中包含空格的时候要格外小心.Bash 变量要用引号括起来, 比如 "$FOO".尽量使用 -0 或 -print0 选项以便用 NULL 来分隔文件名, 例如 locate -0 pattern | xargs -0 ls -al 或 find / -print0 -type d | xargs -0 ls -al.如果 for 循环中循环访问的文件名含有空字符(空格、tab 等字符), 只需用 IFS=$'\n' 把内部字段分隔符设为换行符.

. 在 Bash 脚本中, 使用 set -x 去调试输出(或者使用它的变体 set -v, 它会记录原始输入, 包括多余的参数和注释).尽可能地使用严格模式: 使用 set -e 令脚本在发生错误时退出而不是继续运行; 使用 set -u 来检查是否使用了未赋值的变量; 试试 set -o pipefail, 它可以监测管道中的错误.当牵扯到很多脚本时, 使用 trap 来检测 ERR 和 EXIT.一个好的习惯是在脚本文件开头这样写, 这会使它能够检测一些错误, 并在错误发生时中断程序并输出信息:

      set -euo pipefail
      trap "echo 'error: Script failed: see failed command above'" ERR

. 在 Bash 脚本中, 子 shell(使用括号 (...))是一种组织参数的便捷方式.一个常见的例子是临时地移动工作路径, 代码如下:
      # do something in current dir
      (cd /some/other/dir && other-command)
      # continue in original dir

. 在 Bash 中, 变量有许多的扩展方式.${name:?error message} 用于检查变量是否存在.此外, 当 Bash 脚本只需要一个参数时, 可以使用这样的代码 input_file=${1:?usage: $0 input_file}.在变量为空时使用默认值: ${name:-default}.如果你要在之前的例子中再加一个(可选的)参数, 可以使用类似这样的代码 output_file=${2:-logfile}, 如果省略了 $2, 它的值就为空, 于是 output_file 就会被设为 logfile.数学表达式: i=$(( (i + 1) % 5 )).序列: {1..10}.截断字符串: ${var%suffix} 和 ${var#prefix}.例如, 假设 var=foo.pdf, 那么 echo ${var%.pdf}.txt 将输出 foo.txt.

. 使用括号扩展({...})来减少输入相似文本, 并自动化文本组合.这在某些情况下会很有用, 例如 mv foo.{txt,pdf} some-dir(同时移动两个文件), cp somefile{,.bak}(会被扩展成 cp somefile somefile.bak)或者 mkdir -p test-{a,b,c}/subtest-{1,2,3}(会被扩展成所有可能的组合, 并创建一个目录树).

. 通过使用 <(some command) 可以将输出视为文件.例如, 对比本地文件 /etc/hosts 和一个远程文件:

      diff /etc/hosts <(ssh somehost cat /etc/hosts)

. 编写脚本时, 你可能会想要把代码都放在大括号里.缺少右括号的话, 代码就会因为语法错误而无法执行.如果你的脚本是要放在网上分享供他人使用的, 这样的写法就体现出它的好处了, 因为这样可以防止下载不完全代码被执行.
{
      # 在这里写代码
}

. 在 Bash 中, 同时重定向标准输出和标准错误: some-command >logfile 2>&1 或者 some-command &>logfile.通常, 为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上, 在命令后添加 </dev/null 是一个好习惯.

. 使用 man ascii 查看具有十六进制和十进制值的ASCII表.man unicode, man utf-8, 以及 man latin1 有助于你去了解通用的编码信息.

. 在当前目录下通过文件名查找一个文件, 使用类似于这样的命令: find . -iname '*something*'.在所有路径下通过文件名查找文件, 使用 locate something (但注意到 updatedb 可能没有对最近新建的文件建立索引, 所以你可能无法定位到这些未被索引的文件).

. 了解如何运用 wc 去计算新行数(-l), 字符数(-m), 单词数(-w)以及字节数(-c).

. 了解如何使用 tee 将标准输入复制到文件甚至标准输出, 例如 ls -al | tee file.txt.

. 替换一个或多个文件中出现的字符串:      # 同时备份原文件

      perl -pi.bak -e 's/old-string/new-string/g' my-files-*.txt

. 使用 repren 来批量重命名文件, 或是在多个文件中搜索替换内容.(有些时候 rename 命令也可以批量重命名, 但要注意, 它在不同 Linux 发行版中的功能并不完全一样.)

. 计算文本文件第三列中所有数的和(可能比同等作用的 Python 代码快三倍且代码量少三倍):

      awk '{ x += $3 } END { print x }' myfile

. 使用 shuf 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行.

. 若要了解内存状态, 运行并理解 free 和 vmstat 的输出.值得留意的是“cached”的值, 它指的是 Linux 内核用来作为文件缓存的内存大小, 而与空闲内存无关.

. wireshark, tshark 和 ngrep 可用于复杂的网络调试.

. 了解 strace 和 ltrace.这俩工具在你的程序运行失败、挂起甚至崩溃, 而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的.注意 profile 参数(-c)和附加到一个运行的进程参数 (-p).

. 了解使用 ldd 来检查共享库.但是永远不要在不信任的文件上运行.

. 了解如何运用 gdb 连接到一个运行着的进程并获取它的堆栈轨迹.

. 当调试一些之前出现的问题的时候, sar 非常有用.它展示了 cpu、内存以及网络等的历史数据.

. 关于更深层次的系统分析以及性能分析, 看看 stap(SystemTap), perf, 以及sysdig.

. 如果你删除了一个文件, 但通过 du 发现没有释放预期的磁盘空间, 请检查文件是否被进程占用: lsof | grep deleted | grep "filename-of-my-big-file"

. env: 执行一个命令(脚本文件中很有用)
.printenv: 打印环境变量(调试时或在写脚本文件时很有用)
. look: 查找以特定字符串开头的单词或行
. cut, paste 和 join: 数据修改
. fmt: 格式化文本段落
. pr: 将文本格式化成页／列形式
. column: 将文本格式化成多个对齐、定宽的列或表格
. nl: 添加行号
. seq: 打印数字
. bc: 计算器
. nc: 网络调试及数据传输
. slurm: 网络流量可视化
. stat: 文件信息       # 有用
. tac: 反向输出文件
. shuf: 文件中随机选取几行
. split 和 csplit: 分割文件
. sponge: 在写入前读取所有输入, 在读取文件后再向同一文件写入时比较有用, 例如 grep -v something some-file | sponge some-file
. dstat: 系统状态查看
. glances: 高层次的多子系统总览
. iostat: 硬盘使用状态
. mpstat:  CPU 使用状态
. vmstat:  内存使用状态
. last: 登入记录
. iftop 或 nethogs: 套接字及进程的网络利用情况


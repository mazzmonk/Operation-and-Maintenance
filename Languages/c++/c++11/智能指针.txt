shared_ptr

std::shared_ptr
#include <boost/shared_ptr.hpp>
#include <boost/shared_ptr.hpp>
  C++ 实用工具库 动态内存管理 std::shared_ptr 
在头文件 <memory> 中定义                                                //直接引用似乎没有用，#include <boost/shared_ptr.hpp>这样用，使用时候boost::shared_ptr这样用
template< class T > class shared_ptr;（C++11 起）
std::shared_ptr 是通过指针保持某个对象的共享拥有权的智能指针。若干个 shared_ptr 对象可以拥有同一个对象；最后一个指向该对象的 shared_ptr 被销毁或重置时，该对象被销毁。销毁该对象时使用的是 delete 表达式或者是在构造 shared_ptr 时传入的自定义删除器（deleter）。

shared_ptr 也可以不拥有对象，称作空（empty）。

shared_ptr 满足 CopyConstructible 和 CopyAssignable 的要求。

成员类型	      定义
element_type	T

成员函数
---------------------------------------------------------------------------------------------------------------------------------
(constructor) 	constructs new shared_ptr （公共成员函数）
---------------------------------------------------------------------------------------------------------------------------------
(destructor) 		解构拥有的对象如果没有更多shared_ptrs的的链接 （公共成员函数）
---------------------------------------------------------------------------------------------------------------------------------
 operator= 		分配shared_ptr （公共成员函数）

修饰符
---------------------------------------------------------------------------------------------------------------------------------
reset 			取代管理的对象 （公共成员函数） 
---------------------------------------------------------------------------------------------------------------------------------
swap			掉期所管理的对象 （公共成员函数）

观察员
get 				返回一个指针，指向被管理对象 （公共成员函数）
---------------------------------------------------------------------------------------------------------------------------------
operator*
operator-> 		解引用指针到的管理对象 （公共成员函数）
---------------------------------------------------------------------------------------------------------------------------------
use_count 		返回shared_ptr对象指的是在同一个管理对象的数量 （公共成员函数） 
---------------------------------------------------------------------------------------------------------------------------------
unique 			检查是否被管理对象的管理仅由当前shared_ptr的实例 （公共成员函数） 
---------------------------------------------------------------------------------------------------------------------------------
operator bool 	检查是否有相关的管理对象 （公共成员函数） 
---------------------------------------------------------------------------------------------------------------------------------
owner_before 	业主基于订购的共享指针（公共成员函数） 

非成员函数
make_shared 	创建一个共享管理一个新的对象的指针，该指针（函数模板） 
---------------------------------------------------------------------------------------------------------------------------------
allocate_shared 	创建一个共享指针管理使用分配器分配一个新的对象（函数模板） 
--------------------------------------------------------------------------------------------------------------------------------
static_pointer_cast
dynamic_pointer_cast
const_pointer_cast 	适用于static_cast，dynamic_cast或const_cast被管理对象的类型（函数模板） 
---------------------------------------------------------------------------------------------------------------------------------
get_deleter 			返回指定类型的删除，如果拥有 （函数模板） 
---------------------------------------------------------------------------------------------------------------------------------
operator==
operator!=
operator<
operator<=
operator>
operator>= 			与另一个shared_ptr或nullptr （函数模板） 
---------------------------------------------------------------------------------------------------------------------------------
operator<< 			托管指针的值输出到输出流中（函数模板） 
---------------------------------------------------------------------------------------------------------------------------------
std::swap(std::shared_ptr)  （C++11） 	专业的std::swap算法 （函数模板） 
---------------------------------------------------------------------------------------------------------------------------------
std::atomic_is_lock_free(std::shared_ptr)
std::atomic_load(std::shared_ptr)
std::atomic_load_explicit(std::shared_ptr)
std::atomic_store(std::shared_ptr)
std::atomic_store_explicit(std::shared_ptr)
std::atomic_exchange(std::shared_ptr)
std::atomic_exchange_explicit(std::shared_ptr)
std::atomic_compare_exchange_weak(std::shared_ptr)
std::atomic_compare_exchange_strong(std::shared_ptr)
std::atomic_compare_exchange_weak_explicit(std::shared_ptr)
std::atomic_compare_exchange_strong_explicit(std::shared_ptr) 	专业原子操作 （函数模板） 

Helper类
std::hash<std::shared_ptr>  （C++11） std::shared_ptr的哈希支持 （类模板特化） 

实现说明
在典型的实现中，std::shared_ptr 只保存两个指针：
	指向被管理对象的指针
	指向控制块（control block）的指针

控制块是一个动态分配的对象，其中包含：
	指向被管理对象的指针或被管理对象本身
	删除器
	分配器（allocator）
	拥有被管理对象的 shared_ptr 的数量
	引用被管理对象的 weak_ptr 的数量
通过 std::make_shared 和 std::allocate_shared 创建 shared_ptr 时，控制块将被管理对象本身作为其数据成员；而通过构造函数创建 shared_ptr 时则保存指针。
shared_ptr 持有的指针是通过 get() 返回的；而控制块所持有的指针/对象则是最终引用计数归零时会被删除的那个。两者并不一定相等。
shared_ptr 的析构函数会将控制块中的 shared_ptr 计数器减一，如果减至零，控制块就会调用被管理对象的析构函数。但控制块本身直到 std::weak_ptr 计数器同样归零时才会释放。


std::weak_ptr
在头文件 <memory> 中定义
template< class T > class weak_ptr;（C++11 起）
std::weak_ptr 是一种智能指针，它对被 std::shared_ptr 管理的对象存在非拥有性（“弱”）引用。在访问所引用的对象前必须先转换为 std::shared_ptr。

std::weak_ptr 用来表达临时所有权的概念：当某个对象只有存在时才需要被访问，而且随时可能被他人删除时，可以使用 std::weak_ptr 来跟踪该对象。需要获得临时所有权时，则将其转换为 std::shared_ptr，此时如果原来的 std::shared_ptr 被销毁，则该对象的生命期将被延长至这个临时的 std::shared_ptr 同样被销毁为止。

此外，std::weak_ptr 还可以用来避免 std::shared_ptr 的循环引用。


成员类型		定义
element_type	T

成员函数
(constructor) 	创建一个新的weak_ptr（公共成员函数） 
---------------------------------------------------------------------------------------------------------------------------------
(destructor) 		销毁weak_ptr（公共成员函数） 
---------------------------------------------------------------------------------------------------------------------------------
operator= 		分配weak_ptr（公共成员函数） 

修改器
reset 			释放被管理对象的所有权（公共成员函数） 
---------------------------------------------------------------------------------------------------------------------------------
swap 			交换所管理的对象 （公共成员函数） 

观察者
use_count 		返回shared_ptr对象，管理对象的数量 （公共成员函数） 
---------------------------------------------------------------------------------------------------------------------------------
expired 			检查是否被引用的对象已被删除（公共成员函数） 
---------------------------------------------------------------------------------------------------------------------------------
lock 			创建一个shared_ptr管理引用的对象（公共成员函数） 
---------------------------------------------------------------------------------------------------------------------------------
owner_before 	提供业主弱指针的顺序 （公共成员函数） 

非成员函数
std::swap(std::weak_ptr)  （C++11） 特化std::swap算法 （函数模板） 

示例
演示如何通过锁来保证指针的有效性

#include <iostream>
#include <memory>头文件: "boost/scoped_ptr.hpp"
boost::scoped_ptr 用于确保动态分配的对象能够被正确地删除。
 
std::weak_ptr<int> gw;
 
void f()
{
    if (auto spt = gw.lock()) { // Has to be copied into a shared_ptr before usage
	std::cout << *spt << "\n";
    }
    else {
        std::cout << "gw is expired\n";
    }
}
 
int main()
{
    {
        auto sp = std::make_shared<int>(42);
	gw = sp;
	f();
    }
    f();
}


scoped_ptr
头文件: "boost/scoped_ptr.hpp"
boost::scoped_ptr 用于确保动态分配的对象能够被正确地删除。事实上，scoped_ptr永远不能被复制或被赋值！scoped_ptr 拥有它所指向的资源的所有权，并永远不会放弃这个所有权。scoped_ptr的这种特性提升了我们的代码的表现，我们可以根据需要选择最合适的智能指针(scoped_ptr 或 auto_ptr)。
要决定使用std::auto_ptr还是boost::scoped_ptr, 就要考虑转移所有权是不是你想要的智能指针的一个特性。如果不是，就用scoped_ptr. 它是一种轻量级的智能指针；使用它不会使你的程序变大或变慢。它只会让你的代码更安全，更好维护。

成员函数
explicit scoped_ptr(T* p=0)
构造函数，存储p的一份拷贝。注意，p 必须是用operator new分配的，或者是null. 在构造的时候，不要求T必须是一个完整的类型。当指针p是调用某个分配函数的结果而不是直接调用new得到的时候很有用：因为这个类型不必是完整的，只需要类型T的一个前向声明就可以了。这个构造函数不会抛出异常。

~scoped_ptr()
删除被指物。类型T在被销毁时必须是一个完整的类型。如果scoped_ptr在它被析构时并没有保存资源，它就什么都不做。这个析构函数不会抛出异常。

void reset(T* p=0);
重置一个 scoped_ptr 就是删除它已保存的指针，如果它有的话，并重新保存 p. 通常，资源的生存期管理应该完全由scoped_ptr自己处理，但是在极少数时候，资源需要在scoped_ptr的析构之前释放，或者scoped_ptr要处理它原有资源之外的另外一个资源。这时，就可以用reset，但一定要尽量少用它。(过多地使用它通常表示有设计方面的问题) 这个函数不会抛出异常。

T& operator*() const;
返回一个到被保存指针指向的对象的引用。由于不允许空的引用，所以解引用一个拥有空指针的scoped_ptr将导致未定义行为。如果不能肯定所含指针是否有效，就用函数get替代解引用。这个函数不会抛出异常。

T* operator->() const;
返回保存的指针。如果保存的指针为空，则调用这个函数会导致未定义行为。如果不能肯定指针是否空的，最好使用函数get。这个函数不会抛出异常。

T* get() const;
返回保存的指针。应该小心地使用get，因为它可以直接操作裸指针。但是，get使得你可以测试保存的指针是否为空。这个函数不会抛出异常。get通常在调用那些需要裸指针的函数时使用。

operator unspecified_bool_type() const
返回scoped_ptr是否为非空。返回值的类型是未指明的，但这个类型可被用于Boolean的上下文中。在if语句中最好使用这个类型转换函数，而不要用get去测试scoped_ptr的有效性

void swap(scoped_ptr& b)
交换两个scoped_ptr的内容。这个函数不会抛出异常。

普通函数
template<typename T> void swap(scoped_ptr<T>& a,scoped_ptr<T>& b)
这个函数提供了交换两个scoped pointer的内容的更好的方法。之所以说它更好，是因为 swap(scoped1,scoped2)可以更广泛地用于很多指针类型，包括裸指针和第三方的智能指针。scoped1.swap(scoped2) 则只能用于它的定义所在的智能指针，而不能用于裸指针。

你可为那些不够智能，没有提供它们自己的交换函数的智能指针创建你的普通swap函数。

用法
scoped_ptr的用法与普通的指针没什么区别；最大的差别在于你不必再记得在指针上调用delete，还有复制是不允许的。典型的指针操作(operator* 和 operator->)都被重载了，并提供了和裸指针一样的语法。用scoped_ptr和用裸指针一样快，也没有大小上的增加，因此它们可以广泛使用。使用boost::scoped_ptr时，包含头文件"boost/scoped_ptr.hpp". 在声明一个scoped_ptr时，用被指物的类型来指定类模板的参数。例如，以下是一个包含std::string指针的scoped_ptr：

boost::scoped_ptr<std::string> p(new std::string("Hello"));
当scoped_ptr被销毁时，它对它所拥有的指针调用delete 。

boost::scoped_ptr的实现和std::auto_ptr非常类似，都是利用了一个栈上的对象去管理一个堆上的对象，从而使得堆上的对象随着栈上的对象销毁时自动删除。不同的是，boost::scoped_ptr有着更严格的使用限制——不能拷贝。这就意味着：boost::scoped_ptr指针是不能转换其所有权的。

1.不能转换所有权
boost::scoped_ptr所管理的对象生命周期仅仅局限于一个区间（该指针所在的"{}"之间），无法传到区间之外，这就意味着boost::scoped_ptr对象是不能作为函数的返回值的（std::auto_ptr可以）。
2.不能共享所有权
这点和std::auto_ptr类似。这个特点一方面使得该指针简单易用。另一方面也造成了功能的薄弱——不能用于stl的容器中。
3.不能用于管理数组对象
由于boost::scoped_ptr是通过delete来删除所管理对象的，而数组对象必须通过deletep[]来删除，因此boost::scoped_ptr是不能管理数组对象的，如果要管理数组对象需要使用boost::scoped_array类。

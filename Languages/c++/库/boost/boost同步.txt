同步计时器
io_service io
deadline_timer t
t.wait();
x        x为执行程序


异步计时器
io_service io
deadline_timer t
t.async_wait(x)  x为回调函数
io.run()

回调函数在io.run执行完后执行


boost::bind
bind是一组重载的函数模板
用来向一个函数(或函数对象)绑定某些参数. 
bind的返回值是一个函数对象.

void fun(int x,int y)
{
	cout << x << "," << y << endl;
}

对于像fun这样的普通函数.若fun有n个参数.则bind需要 n+1 个参数:原始函数的地址以及n个要绑定的参数.

第1种用法：
boost::bind(&fun,3,4)
表示将 3 和 4 作为参数绑定到 fun 函数. 
因为绑定了所有的参数. 现在我们调用bind所返回的函数对象:
boost::bind(&fun, 3, 4)( );  //无参数. 
就会输出 3, 4

第2种用法：
向原始函数 fun 绑定一部分参数
boost::bind(&fun, 3, _1)    // bind的实参表依次还是: 要绑定的函数的地址, 要绑定到fun的第一个参数值, 然后注意
        // 因为我们不打算向fun绑定第2个参数(即我们希望在调用返回的Functor时再指定这个参数的值)
        // 所以这里使用 _1 来占位. 这里的 _1 代表该新函数对象被调用时. 实参表的第1个参数.
        // 同理下边还会用到 _2 _3 这样的占位符. 
这里只为fun绑定了第一个参数3. 所以在调用bind返回的函数对象时. 需要:
 boost::bind(&fun, 3, _1)(4);  //这个4 会代替 _1 占位符.

第3种用法：
不向 fun 绑定任何参数
 boost::bind(&fun, _1, _2)   // _1 _2 都是占位符. 上边已经说过了.
所以它就是 将新函数对象在调用时的实参表的第1个参数和第2个参数 绑定到fun函数.  
 boost::bind(&fun, _1, _2)(3, 4);    // 3将代替_1占位符, 4将代替_2占位符.
输出 3, 4
同理 boost::bind(&fun, _2, _1)(3, 4);   // 3将代替_1占位符, 4将代替_2占位符.
会输出 4, 3  
同理 boost::bind(&fun, _1, _1)(3);     // 3将代替_1占位符
会输出 3, 3


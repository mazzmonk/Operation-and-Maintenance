#include <iostream>
#include <pthread.h>

pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
int counter = 0;

void* functionC(void*) {
  pthread_mutex_lock(&mutex1);
  counter++;
  std::cout << "Counter value: " << counter << std::endl;
  pthread_mutex_unlock(&mutex1);
}

int main(int argc, char* argv[]) {
  int rc1,rc2;
  pthread_t thread1,thread2;
  void* (*pmf)(void*);
  pmf = functionC;

  if ((rc1 = pthread_create(&thread1,NULL,&functionC,NULL))) {
    std::cout << "Thread1 create fail " << rc1 << std::endl;
  }
  if ((rc2 = pthread_create(&thread2,NULL,&functionC,NULL))) {
    std::cout << "Thread2 create fail " << rc2 << std::endl;
  }
  pthread_join(thread1,NULL);
  pthread_join(thread2,NULL);

  return 0;
}

编译时加上-lpthread

pthread_create原型：
extern int pthread_create (pthread_t *__restrict __newthread,
         const pthread_attr_t *__restrict __attr,
         void *(*__start_routine) (void *),
         void *__restrict __arg) __THROWNL __nonnull ((1, 3));

第一个参数为指向线程标识符的指针
第二个参数用来设置线程属性
第三参数是线程运行函数的起始地址
第四个参数是运行函数的参数
成功则返回0，否则返回出错编号，如果创建成功，新建的线程则运行参数三和参数四确定的函数，原线程则继续运行下一行代码。

如果有第四个参数，见如下例子：

#include <iostream>
#include <pthread.h>

struct char_print_parms {       //把第三个函数中用的参数填入到一个struct中
	char character;
	int count;
};

void char_print(char character, int count) {
	std::cout << character << std::endl;
	std::cout << count << std::endl;
}

int main(int argc, char* argv[]) 
{
	pthread_t thread1_id;
	struct char_print_parms thread1_args;
		
	thread1_args.character = 'x';
	thread1_args.count = 30000;
	
	pthread_create(&thread1_id,NULL,&char_print,&thread1_args);  //第四个参数用的struct的地址

	pthread_t thread2_id;
	struct char_print_parms thread2_args;
	thread2_args.character = 'o';
	thread2_args.count = 20000;

	pthread_create(&thread2_id,NULL,&char_print,&thread2_args);

	pthread_join(thread1_id,NULL);
	pthread_join(thread2_id,NULL);
	
  return 0;
}


这里的例子锁是个全局变量,每个线程往buff[]这个数组里写数据.
#include <iostream>
#include <pthread.h>

#define MAXNUM 20

struct {
  pthread_mutex_t mutex;
  int buff[MAXNUM];
} shared = { PTHREAD_MUTEX_INITIALIZER };

void *produce(void *);

int main(int argc, char* argv[]) {
  pthread_t thread1_id, thread2_id, thread3_id, thread4_id;

  pthread_create(&thread1_id, NULL, &produce, NULL);
  pthread_create(&thread2_id, NULL, &produce, NULL);
  pthread_create(&thread3_id, NULL, &produce, NULL);
  pthread_create(&thread4_id, NULL, &produce, NULL);

  pthread_join(thread1_id, NULL);
  pthread_join(thread2_id, NULL);
  pthread_join(thread3_id, NULL);
  pthread_join(thread4_id, NULL);

  for (int i = 0; i < MAXNUM; i++) {
    std::cout << shared.buff[i] << "\t";
    if (shared.buff[i] == 0)
      break;
  }
  return 0;
}

void *produce(void *) {
  pthread_mutex_lock(&shared.mutex);
  for (int i = 0; i < MAXNUM; i++) {
    if (shared.buff[i] == 0) {
      shared.buff[i] = i + 1;
      std::cout << shared.buff[i] << "\t";
      break;
    }
  }
  std::cout << std::endl;
  pthread_mutex_unlock(&shared.mutex);
}



pthread_join原型：
extern int pthread_join (pthread_t __th, void **__thread_return);

第一个参数指等待退出线程的线程号
第二个参数退出线程的返回值

如果主线程，也就是main函数执行的那个线程，在其他线程退出之前就已经退出，那么带来的bug就无法预知。
通过pthread_join函数会让主线程阻塞，直到所有线程都已经退出。这样主线程可以清理其他线程的环境。
但是还有些线程，希望自己来清理退出状态，也不需要主线程调用pthread_join来等待他们。我们将此类线程
的属性称为detached。如果在调用pthread_create()函数的时候将属性设置为NULL，则采用的默认属性，也
就是joinable

如果线程要设置为detach，用2种方法：
1.pthread_detach()
2.在创建线程时候设置pthread_create_detached属性


linux线程执行和windows不同，pthread有两种状态joinable状态和unjoinable状态
* 如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了pthread_join之后这些资源才会被释放。
* 若是unjoinable状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放。unjoinable属性可以在pthread_create时指定，或在线程创建后在线程中pthread_detach自己, 如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。或者将线程置为 joinable,然后适时调用pthread_join。
头一种方法就是在线程函数头加上pthread_detach(pthread_self())，线程状态改变，在函数尾部直接pthread_exit线程就会自动退出。

#include <pthread.h> 
函数原型：pthread_t pthread_self(void);
函数作用：获得线程自身的ID。pthread_t的类型为unsigned long int，所以在打印的时候要使用%lu方式，否则将产生奇怪的结果。
功能：获取当前调用线程的 thread identifier(标识号).


pthread_detach(threadid)和pthread_deatach(pthread_self())的区别就是调用他们的线程不同。
pthread_detach(threadid)函数的功能是使线程ID为threadid的线程处于分离状态，一旦线程处于分离状态，该线程终止时底层资源立即被回收;否则终止子线程的状态一直保存(占用系统资源)直到主线程调用pthread_join(threadid,NULL)获取线程的退出状态。通常是主线程使用pthread_create()创建子线程以后，一般可以调用pthread_detach(threadid)分离刚刚创建的子线程，这里的threadid是子线程的threadid;如此以来，该子线程终止时底层资源立即回收;被创建的子线程有可以自己分离自己，子线程调用pthread_detach(pthread_self())就是分离自己，因为pthread_id()这个函数返回的是自己的线程ID。

一个线程或者是可汇合的(joinabe，缺省值)，或者是脱离的(detached)。该属性在创建线程的时候指定。
joinable线程可在创建后，用pthread_detach()显式地分离。但分离后不可以再合并。该操作不可逆。
为了确保移植性，在创建线程时，最好显式指定其join或detach属性。似乎不是所有POSIX实现都是用joinable作默认。
创建一个线程默认状态是joinable，如果一个线程结束运行但没有被join，则它的状态类似于进程中的Zombie Process，即还有一部分资源没被回收(退出状态码)，所以创建线程者应该调用pthread_join来等待线程运行结束，并可得到线程的退出代码，回收其资源(类似wait，waitpid)，但是调用pthread_join(pthread_id)后，如果该线程没有运行结束，调用者会被阻塞，某些情况下我们不希望如此，比如web服务的主线程创建一个子线程，主线程不能因为调用pthread_join而阻塞，如此可以在子线程中加如代码:
pthread_detach(pthread_self())或者父线程调用pthread_detach(thread_id)(非阻塞，可立即返回)，此时子线程的状态将设置为detached，则该子线程运行结束后会自动释放所有资源。







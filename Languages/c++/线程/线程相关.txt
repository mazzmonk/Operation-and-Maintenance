c++标准库使用future为这类一次性事件建模.如果一个线程需要等待特定一次性事件,那么它就会获取一个future来代表这一事件.然后,该线程可以周期性地在这个future上等待一小段时间以检查事件是否发生,而在检查间隙执行其他任务.另外,它还可以去做另外一个任务,直到其所需事件已发生才继续进行,随后就等待future变为就绪.future可能会与之相关的数据,或可能没有.一旦事件已经发生(即future已变为就绪),future就无法复位.

c++标准库中有两类future,是由<future>库的头文件中声明的两类模板实现的:唯一future(unique futures,std::future<>)和共享future(shared futures,std::shared_future<>).
std::future的实例是仅有的一个指向其关联事件的实例,而多个std::shared_future的实例则可以指向同一事件.对于后者而言,所有实例将同时变为就绪,并且它们都可以访问所有与该事件关联的数据.

虽然future被用于线程通信,但是future对象本身却并不提供同步访问.如果多个线程需要访问同一个future对象,它们必须通过互斥元或其他同步机制来保护访问,多个线程可以分别访问自己的std::shared_future<>副本而无需进一步的同步,即使它们都指向同一个异步结果.


1.假如你有一个长期运行的任务,预期最终将得到一个有用的结果,但是现在,你还不需要这个指.你可以启动一个新的线程来执行该计算,但这也意味你必须注意将结果传回来,因为std::thread并没有提供直接的机制来这样做.这就是std::async函数模板
在不需要立刻得到结果的时候,可以使用std::async来启动一个异步任务.std::async返回一个std::future对象,而不是给你一个std::thread对象让你在上面等待,std::future对象最终将持有函数的返回值.当需要这个值时,只要在future上调用get(),线程就会阻塞直到future就绪,然后返回该值

2.std::packaged_task<>将一个future绑定到一个函数或者可调用对象上.当std::packaged_task<>对象被调用时,它就调用相关联的函数和可调用对象,并且让future就绪,将返回值作为关联数据存储

3.那些无法用一个简单函数调用表达式的任务和那些结果可能来自不止一个地方的任务,使用std::promise来显式地设置值
类模板std::promise提供储存类型为T的值或异常,之后通过std::promise对象所创建的std::future对象非同步获得结果．



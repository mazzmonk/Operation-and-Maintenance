前20大C++多线程错误以及如何避免这些错误

错误＃1：在终止应用程序之前不使用join（）等待后台线程
如果我们在主程序终止之前忘记加入一个线程或将其分离（使其不可访问），则会导致程序崩溃。


错误＃2：试图加入以前已经脱离的线程
如果你已经分离了一个线程，并且在某些时候，你不能重新加入主线程
问题是这不会导致编译错误（这将是很好！）; 相反，它会使您的程序崩溃。
解决方案是在尝试将其加入调用线程之前始终检查线程是否可以加入。

int main（）
{
  thread t1（LaunchRocket）;
  t1.detach（）;
  // ..... 100行代码
  
  if（t1.joinable（））
  {
    t1.join（）; 
  }
  
  return 0;
}


错误＃3：不知道std :: thread :: join（）阻塞调用线程	
在现实世界的应用程序中，您经常需要为工作线程处理长时间运行的操作来处理网络I / O或等待用户按下按钮。在主应用程序（UI线程处理渲染）中调用这些工作线程上的join可能会导致应用程序冻结。通常有更好的方法来处理这个。

错误＃4：假设线程函数参数默认通过引用传递
线程函数参数是按默认值传递的。因此，如果您需要在传入的参数中保留更改，则需要使用std :: ref（）通过引用传递它们。


错误＃5：不保护共享数据或共享资源与关键部分（例如互斥体）
在多线程环境中，多个线程经常竞争资源或共享数据。这通常会导致资源或数据的未定义的行为，除非资源或数据受到使用一些只允许一个线程一次作用的机制来保护。
在下面的例子中，std :: cout是由6个线程（t1-t5 + main）共享的共享资源。

#include "stdafx.h"
#include <iostream>
#include <string>
#include <thread>
#include <mutex>
using namespace std;
std::mutex mu;
void CallHome(string message)
{
  cout << "Thread " << this_thread::get_id() << " says " << message << endl;
}
int main()
{
  thread t1(CallHome, "Hello from Jupiter");
  thread t2(CallHome, "Hello from Pluto");
  thread t3(CallHome, "Hello from Moon");
  CallHome("Hello from Main/Earth");
  thread t4(CallHome, "Hello from Uranus");
  thread t5(CallHome, "Hello from Neptune");
  t1.join();
  t2.join();
  t3.join();
  t4.join();
  t5.join();
  return 0;
}

这是因为五个线程以随机方式获取std :: cout资源。为了使输出更加确定，解决方案是使用std :: mutex保护对std :: cout资源的访问。在使用std :: cout之前，请更改CallHome（）获取互斥锁，并在完成后释放。

void CallHome （string message ） 
{
  mu.lock （）;
  cout << “Thread” << this_thread :: get_id （）<< “say” << message << endl;
  mu.unlock （）;
}


错误＃6：忘记在关键部分后释放锁
在上一节中，您看到了如何使用互斥锁来保护关键部分。但是，在互斥锁上调用lock（）和unlock（）是不可取的，因为您可能忘记放弃所持有的锁。那会怎么样？那么正在等待该资源的所有其他线程将被无限期地阻止，程序可能挂起。

您应该使用 使用RAII风格的std :: lock_guard来管理互斥锁的持续时间。当lock_guard对象被创建时，它会尝试获取互斥体的所有权。当lock_guard对象超出范围时，lock_guard对象被销毁，释放互斥体。

我们将修改我们的CallHome方法，使用std :: lock_guard对象：

void CallHome （string message ） 
{
  std :: lock_guard <std :: mutex> lock （mu ）; //获取互斥体
  cout << “Thread” << this_thread :: get_id （）<< “说” << message << endl;
} // lock_guard对象被销毁，并且mutex mu被释放


错误＃7：不要将关键部分保持尽可能小型化
当一个线程在关键部分内部执行时，尝试进入关键部分的所有其他线程基本上被阻止。因此，我们应该将指令放在尽可能小的关键部分内。


错误＃8：不按相同的顺序获取多个锁
这是DEADLOCK最常见的原因之一，线程由于正在等待获取对其他被阻塞线程锁定的资源的访问而无限期地阻塞。

最好的做法是以这样一种方式构造你的代码，即所有的锁都是以相同的顺序获得的。
根据您的情况，您还可以采用以下策略：

如果两个都需要被锁，就一起收集锁：

std :: lock_guard <std :: mutex，std :: mutex> lock （muA，muB ）;


错误＃9：尝试获取std :: mutex两次
尝试两次获取互斥将导致未定义的行为。在大多数调试实现中，可能会导致崩溃。


错误＃10：当std :: atomic类型就足够了时使用互斥体
当您需要更新需要更新的简单数据类型时，例如，使用std：atomic的简单布尔或整数计数器几乎可以比使用互斥体产生更好的性能。

不要这样做:
int counter;
....
mu.lock();
counter++;
mu.unlock();

替换如下方式:
std::atomic<int> counter;
...
counter++;


错误＃11：使用线程池时可以直接创建和销毁大量线程
创建和删除线程在CPU时间方面是昂贵的。想象一下，当系统尝试执行复杂的过程，如渲染图形或计算游戏物理时，试图创建一个线程。通常采用的一种技术是创建一个预先分配的线程池，可以处理常规任务，例如在整个生命周期中记录到磁盘或在网络上发送数据。

使用线程池线程而不是自己创造的另一个好处是，您不必担心超额预订，从而影响系统性能。

两个最流行的实现线程池的库是Intel Thread Building Blocks（TBB）和Microsoft Parallel Patterns Library（PPL）。


错误＃12：不处理后台线程中的异常
在一个线程中抛出的异常不能被另一个线程捕获。我们假设我们有一个可以抛出异常的函数。如果我们在main中分离线程执行此函数，并且希望在主线程中捕获此线程的任何异常，它将无法正常工作。这里有一个例子：


#include "stdafx.h"
#include<iostream>
#include<thread>
#include<exception>
#include<stdexcept>
static std::exception_ptr teptr = nullptr;
void LaunchRocket()
{
  throw std::runtime_error("Catch me in MAIN");
}
int main()
{
  try
  {
    std::thread t1(LaunchRocket);
    t1.join();
  }
  catch (const std::exception &ex)
  {
    std::cout << "Thread exited with exception: " << ex.what() << "\n";
  }
  return 0;
}

上述程序将崩溃，main（）中的catch块将不会处理抛出的线程t1的异常。

解决方案是使用C ++ 11功能std :: exception_ptr捕获在后台线程中抛出的异常。以下是您需要执行的步骤：
1.创建一个std :: exception_ptr的全局实例，初始化为nullptr
2.在分叉线程中执行的函数内部，捕获任何异常并将std :: current_exception（）设置为步骤＃1中的std :: exception_ptr
3.在主线程内，检查是否设置了全局异常指针。
4.如果是，请使用std :: rethrow_exception（exception_ptr p）重新引用由exception_ptr参数引用的异常。

引用异常的返回参数不必在同一个线程中完成，该线程首先生成引用的异常，这使得此功能非常适合于跨不同线程处理异常。

以下代码实现了后台线程中异常的安全处理。

#include "stdafx.h"
#include<iostream>
#include<thread>
#include<exception>
#include<stdexcept>
static std::exception_ptr globalExceptionPtr = nullptr;
void LaunchRocket()
{
  try
  {
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    throw std::runtime_error("Catch me in MAIN");
  }
  catch (...)
  {
    //Set the global exception pointer in case of an exception
    globalExceptionPtr = std::current_exception();
  }
}
int main()
{
  std::thread t1(LaunchRocket);
  t1.join();
  if (globalExceptionPtr)
  {
    try
    {
      std::rethrow_exception(globalExceptionPtr);
    }
    catch (const std::exception &ex)
    {
      std::cout << "Thread exited with exception: " << ex.what() << "\n";
    }
  }
  return 0;
}


错误＃13：当std :: async将会执行时，使用线程来模拟Asyn作业
如果您只需要一些异步执行的代码，即不阻止主线程的执行，最好的办法是使用std :: async功能来执行代码。通过创建线程并通过函数指针或lambda参数将可执行代码传递给线程也可以实现相同的操作。然而，在后一种情况下，您负责管理创建和加入/分离它们的线程，以及处理线程中可能发生的任何异常。如果您使用std :: async，您只需摆脱所有这些麻烦，并大大减少陷入死锁情况的机会。

使用std :: async的另一个巨大优点是能够将任务的结果通过std :: future对象传递回调用线程。例如，假设我们有一个函数ConjureMagic返回一个int，我们可以创建一个异步任务，在完成后设置一个Future，并且在适时的时候我们可以在调用线程中从Future提取结果。

//创建一个异步任务，并获得Future的处理 
std :: future asyncResult2 = std :: async （＆ConjureMagic ）;

// ...在设置未来时进行一些处理

//获取未来的结果 
 int v = asyncResult2.get （）;

相反，将结果从工作线程恢复到调用线程要麻烦得多。这两个选项包括：

1.将结果变量的引用传递给线程存储结果的线程。
2.将结果存储在函数对象的类memeber变量中，一旦线程完成执行，该函数对象就可以被检索。

总而言之，默认情况下使用std :: async，除非您可以直接找到使用std :: thread的好理由。


错误＃14：如果需要异步，不使用std :: launch :: async
std :: async有点不正确，因为默认形式的函数可能不会以异步方式执行！

std :: async有两种启动策略：
1.std::launch::async : 一个任务启动被独立的线程立即
2.std::launch::deferred: 任务不立即启动，but is deferred until a .get() or .wait() call is made on the future returned by the std::async. At the point such a call is made，任务被执行．

当std :: async与deafult参数一起启动时，它是这两个策略的组合，这基本上使得行为不可预测。还有一些其他的复杂问题，使用std：async与默认启动参数进行标记 - 这些包括无法预测线程本地变量是否被正确访问，异步任务运行的风险不会因为.get（ ）或.wait（）可能不会被调用沿着所有的编程路径和循环等待Future的状态准备好永远不会完成，因为std :: async返回的Future可能在延迟状态开始。

所以，为了避免所有这些并发症，总是使用std :: launch :: async启动参数启动std :: async。

不要这样做
//使用默认std :: async策略运行myFunction                          
auto myFuture = std :: async （myFunction ）;

替代:
//异步运行myFunction                          
auto myFuture = std :: async （std :: launch :: async，myFunction ）;


错误＃15：在std :: future中以时间敏感的代码路径调用.Get（）

以下代码检索异步任务返回的Future结果。但是，while循环将被阻塞，直到异步任务完成（在这种情况下为10秒）。如果您将此视为在屏幕上呈现数据的循环，则可能导致非常糟糕的用户体验。

#include "stdafx.h"
#include <future>
#include <iostream>
int main()
{
  std::future<int> myFuture = std::async(std::launch::async, []()
  {
    std::this_thread::sleep_for(std::chrono::seconds(10));
    return 8;
  });

  // Update Loop for rendering data
  while (true)
  {
    // Render some info on the screen           
    std::cout << "Rendering Data" << std::endl;
    int val = myFuture.get(); // this blocks for 10 seconds
                  // Do some processing with Val
  }
  return 0;
}

注意：上面的代码还有一个问题 - 它尝试在没有共享状态的情况下第二次轮询Future - 因为Future的状态在循环的第一次迭代中被检索。
解决方案是在调用t.get（）之前检查未来是否有效。这样我们既不阻止异步工作的完成，也不会对已经检索到的Future进行轮询。

以下是实现此功能的代码段：

#include "stdafx.h"
#include <future>
#include <iostream>
int main()
{
  std::future<int> myFuture = std::async(std::launch::async, []()
  {
    std::this_thread::sleep_for(std::chrono::seconds(10));
    return 8;
  });
  // Update Loop for rendering data
  while (true)
  {
    // Render some info on the screen           
    std::cout << "Rendering Data" << std::endl;
    if (myFuture.valid())
    {
      int val = myFuture.get(); // this blocks for 10 seconds
      // Do some processing with Val
    }
  }
  return 0;
}


错误＃16：不知道在调用std :: future :: get（）时传播异步任务中的异常。
假设你有以下代码 - 你认为调用std :: future :: get（）的结果是什么？

#include“stdafx.h”
#include <future>
#include <iostream>
int main （） 
{
  std :: future < int > myFuture = std :: async （std :: launch :: async，[ ] （）
  {
    throw std :: runtime_error （“Catch me in MAIN” ）;
    return 8 ; 
  } ）;
  if（myFuture.valid()） 
  {
    int result = myFuture.get （）;
  }
  return 0 ; 
}
如果你猜到崩溃，你是绝对正确的！
异步任务的异常仅在我们呼吁未来时传播。如果get不被调用，则在将来超出范围时，异常被忽略并被丢弃。
所以，如果你的异步任务可以抛出，你应该总是将调用包装到一个try / catch块中的std :: future :: get（）。这里有一个例子：

#include“stdafx.h”
#include <future>
#include <iostream>
int main （） 
{
	std :: future < int > myFuture = std :: async （std :: launch :: async，[ ] （） 
    {
      throw std :: runtime_error （“Catch me in MAIN” ）;
      return 8 ; 
     } ）;

    if（myFuture.valid（）） 
    {
     try
     {
       int result = myFuture.get （）;
     }
     catch （const std :: runtime_error＆e ） 
     {
       std :: cout << “异步任务抛出异常：” << e。what （）<< std :: endl;
     }
    }
  return 0 ; 
}


错误＃17：当需要精细控制线程执行时，使用std :: async
在大多数情况下，使用std :: async应该足够，在某些情况下，您需要对执行代码的线程进行更精细的控制。例如，如果要将线程固定到多处理器系统（如Xbox等）中的特定CPU内核，以下代码将线程的处理器关联设置为系统的核心5。

#include "stdafx.h"
#include <windows.h>
#include <iostream>
#include <thread>
using namespace std;
void LaunchRocket()
{
  cout << "Launching Rocket" << endl;
}
int main()
{
  thread t1(LaunchRocket);
  DWORD result = ::SetThreadIdealProcessor(t1.native_handle(), 5);
  t1.join();
  return 0;
}


错误＃18：创建比可用内核更多的“Runnable”线程
线程可以从设计角度分为两种类型 - 可运行线程和Waitable线程。

可运行线程消耗其运行核心的CPU时间的100％。当多个可运行线程安排在单个核心上时，它们可以有效地将核心的CPU时间分片。当在单个核心上安排多个可运行线程时，实际上没有实现性能提升 - 实际上由于涉及到附加的上下文切换而导致性能下降。

等待线程等待事件或网络I / O等待时，等待线程仅消耗其运行的核心周期数。这将使CPU核心的大部分可用计算时间未被使用。这就是为什么在一个核心上安排多个等待线程是有益的，因为一个可等待的线程可以处理数据，而其他线程可以等待某些事件发生。在单个核心上安排多个等待线程可以从您的程序提供更大的吞吐量。

那么，如何获得系统可以支持的可运行线程数量？使用std :: thread :: hardware_concurrency（）。这个函数通常会返回处理器内核的数量，但是如果由于超线程而导致核心作为两个或多个逻辑内核的因素  。

您应该使用目标平台中的值来规划程序应同时使用的最多可运行线程数。您还可以为所有等待线程指定一个核心，并使用剩余数量的内核作为可运行线程。例如，在四核系统上，对于所有等待线程使用一个内核，并为其余三个内核使用三个可运行线程。根据线程调度器的效率，您的可运行线程中的一些可能会使上下文切换（由于页面错误等）使核心空闲一段时间。如果在分析期间观察到这种情况，则应该创建比核心数更多的可运行线程，并为系统调整它。 


错误＃19：使用“volatile”关键字进行同步
变量类型声明前面的“volatile”关键字并不会使该变量的操作以原子或线程的方式安全。你可能想要的是std :: atomic。


错误＃20：使用无锁架构，除非绝对需要

有一些复杂的东西吸引着每个工程师。与常规同步机制（如互斥量，条件变量，异步等）相比，锁定免费编程听起来非常性感。但是，我所说的每一个经验丰富的C ++开发人员都认为使用无锁编程作为第一手段是一种过早的形式优化可以在适当的时候最大限度地困扰你（当你没有完整的堆转储时，想想在生产中崩溃！）。

在我的C ++生涯中，只有一件技术需要执行无锁代码，因为我们处于资源有限的系统中，我们组件的每个事务都需要不超过10微秒。

所以，在开始思考无锁路线之前，请先问问自己这三个问题：

您是否考虑过设计系统，使其不需要同步机制？最好的同步通常是“无同步”！
如果您确实需要同步，您是否分析了代码以了解性能特征？如果是，您是否试图优化热代码路径？
你能扩大规模的istead吗？


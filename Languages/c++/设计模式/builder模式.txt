/* builder.h */
class Builder {
 public:
  virtual ~Builder() {
  }
  virtual void BuilderPartA() = 0;
  virtual void BuilderPartB() = 0;
};

class Director {
 public:
  Director(Builder* pBuilder);
  ~Director();
  void Construct();

 private:
  Builder* m_pBuilder;
};

class ConcreateBuilder1 : public Builder {
 public:
  ConcreateBuilder1() {
  }
  virtual ~ConcreateBuilder1() {
  }
  void BuilderPartA();
  void BuilderPartB();
};

class ConcreateBuilder2 : public Builder {
 public:
  ConcreateBuilder2() {}
  virtual ~ConcreateBuilder2() {}
  void BuilderPartA();
  void BuilderPartB();
};

/* builder.cc */
#include "builder.h"
#include <iostream>

void ConcreateBuilder1::BuilderPartA() {
  std::cout << "BuilderPartA by ConcreateBuilder1\n";
}

void ConcreateBuilder1::BuilderPartB() {
  std::cout << "BuilderPartB by ConcreateBuilder1\n";
}

void ConcreateBuilder2::BuilderPartA() {
  std::cout << "BuilderPartA by ConcreateBuilder2\n";
}

void ConcreateBuilder2::BuilderPartB() {
  std::cout << "BuilderPartB by ConcreateBuilder2\n";
}

Director::Director(Builder* pBuilder)
    : m_pBuilder(pBuilder) {
}

Director::~Director() {
  delete m_pBuilder;
  m_pBuilder = NULL;
}

void Director::Construct() {
  m_pBuilder->BuilderPartA();
  m_pBuilder->BuilderPartB();
}

/* main.cc */
#include "builder.h"

int main(int argc, char* argv[]) {
  Builder* pBuilder1 = new ConcreateBuilder1;
  Director* pDirector1 = new Director(pBuilder1);
  pDirector1->Construct();

  Builder* pBuilder2 = new ConcreateBuilder2;
  Director* pDirector2 = new Director(pBuilder2);
  pDirector2->Construct();

  delete pDirector1;
  delete pDirector2;

  return 0;
}

此种模式有点像生产线模式,最后的组装工作由Director来完成,具体生产的部件由builder基类及子类来完成,基类定义子类继承的虚函数,这些虚函数用于
生产部件,所有的部件子类都继承于同一个基类.最后通过Director来把所有部件子类都拼合一起.



